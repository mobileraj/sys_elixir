
The central question of Joe Armstrong's thesis is stated in his Introduction: "How can we program systems which behave in a reasonable manner in the presence of software errors?" Armstrong claims that the requirements of such systems are satisfied by Erlang/OTP. 

To see why, it is first important to note that Erlang was originally built for telecom applications. These types of applications entail certain requirements, each of which is solved by either the language, library, or OS. There are two which are especially relevant to Armstrong's central question: concurrency, isolation, and fault-tolerance.

Telecom systems are inherently concurrent; each switch may interact with thousands of people simultaneously and so must be able to handle very large numbers of concurrent activities. One of the problems with most languages for implementing telecom systems is that they are inherently sequential and do not support an efficient way to run massive numbers of concurrent processes. Constructs such as hardware processes and threads fail because both they are too expensive to create (and so tens of thousands of OS processes would be unrealistic), and they are not isolated from other systems. Shared resources increases the possibility of many concurrency bugs, such as race conditions and deadlocks. To solve these bugs, popular programming languages will typically employ constructs such as atomic variables, mutexes, futures, and condition variables. To reduce the possibility of these bugs, Erlang avoids shared resources and instead passes data through messages between processes. 

Message passing as opposed to shared state naturally leads to isolation, another requirement for telecom systems.  If messages are used (given they are assumed to be unreliably transmitted and thus not heavily relied upon), isolation results; there are no shared resources to manage access to. In a telecom system, most processes need to be relatively independent; if a session between two people crashes, it should not affect the tens of thousands of other sessions people are running on the switch. In a way, different processes of this type work the same whether they are on the same machine or not, because in both cases state is shared by potentially faulty message passing. Thus, code written for two processes on the same machine can be used virtually unchanged for multiple different machines. For telecom systems, this is very convenient, as they involve a vast web of distributed computers, each of which has the potential to fail. So, Isolation is a natural requirement in this architecture.

Telecom systems must be highly fault-tolerant.  They cannot reasonably afford more than two hours of downtime a year, as downtime means that no communication would be possible. Thus, the system must be able to effectively handle different errors without crashing. But first, to understand fault-tolerance, it is important to take a step back and understand what fault-tolerance means. The fault tolerance of a system is its ability to behave properly in the face of software and hardware errors. An error, according to section 5.3 of Armstrong's thesis, is when a system's behavior deviates from its specification. In other words, an error is a break from the specified flow of a program, or a logic fault. Thus, an error cannot be fixed directly by the logic (i.e. specified flow) of the process containing the error. If a process with a fatal error were to try to keep running the process could possibly corrupt data or otherwise cause further errors. The error must be handled by a separate process. At least two processes are necessary, then, to build a fault tolerant system. 

It then becomes impossible to be fully fault-tolerant in a sequential language. Fault tolerance is bound to concurrency, as it is necessary to run multiple processes to build a fault-tolerant system. Due to its high concurrency support at the language, level Erlang enable's a system to be fault-tolerant. It implements this pattern in the Open Telecom Platform (OTP), which serves as the standard library for Erlang. 

 Following from this observation is that these processes must be isolated. Each process must contain their errors. If an error in one process was not contained, then other process (which are loosely or not-at-all related) could fail. Faults would echo in the codebase. Not only does this making debugging large systems incredibly difficult, this makes fault-tolerance nearly impossible to achieve. With a lack of error isolation built into the system, a single pair of processes may be fault-tolerant, but in a system with tens of thousands of processes, this pair may crash due to faults outside of their code. As a corollary to error containment, processes must isolate their resources. If one process fails and corrupts a shared resource, all other processes using that resource will fail too. And so, isolation is essential to error containment. As previously discussed, isolation is built into Erlang. An error in one process does not directly affect other processes, and there are no pointers or shared memory. Systems built by Erlang then have the potential to be extremely reliable.

And so, due to its design features, Erlang becomes a natural candidate for building fault-tolerant systems.

In practice, Erlang has been proven to work well. In its first major experiment, Erlang  (ACS/Dunder) was estimated to improve productivity by 9 to 22 times over PLEX, the language originally used for such an application. Later, a project called the *Mobility Server* (which was based off of the ACS/Dunder) began development. The project became a success and within five years of its release, the *Mobility Server* was used by the European Parliament and marketed in twelve different countries.  

The AXD301 switch is an example of Erlang's success. In 1987, Ericsson's AXE-N project began. This project was intended to construct a "next-generation \[telecom\] switch." This was a major project; it spanned about eight years and cost an estimated ten billion dollars. It expressed the goal to create "one single, universal system for all telecommunications" â€” a goal comparable to that of the internet. [^1] In 1995, the project collapsed, having been regarded as a total failure. Soon afterward, it was restarted using Erlang. With over 1.1 million lines of code and in roughly half of the time spent on the original project, the AXD301 switch was created. With its high scalability and reliability, this switch became a major improvement in the telecom switch market. 

As another past example is a product called the Bluetail Mail Robustifier (BMR), both of which were implemented with Erlang. The BMR was designed as a middleman/proxy between clients and email services. The clients would connect to the BMR proxy which would intercept and relay messages to the back-end servers. This system had similar requirements to the telecom systems, including fault-tolerance. If one email server was to fail, the BMR would switch to a different server without the client noticing a failure. In addition, stringent downtime restrictions (within a few minutes per decade) were imposed on the system. Since its creation, it received millions of emails every year. Bluetail has heavily relied on Erlang's resilience to errors to create successful projects. 

These case studies, explored in Armstrong's thesis, attest to the practical reliability and scalability of Erlang/OTP systems. In section 8.5, Armstrong states that these systems were "so reliable that the people operating these system \[*sic*\] \[were\] inclined to think they are error-free." They became the "market leaders in their niches." Erlang/OTP proved itself to work as a practical fault-tolerant system.

To this day, Erlang is ubiquitous, appearing in mobile networks, games, chat apps, finance-related services, and health services. In fact, roughly 90% of all internet traffic goes through Erlang controlled nodes.[^2] The top eight service providers use Erlang based systems to control their networks, along with 100+ other service providers worldwide. Ericsson, which uses Erlang at the core of its network infrastructure, had 24% of the global mobile base station market in 2022.[^3]

Riot games, which is primarily known for its massive multiplayer online (MMO) game *League of Legends*, uses and Erlang messaging system which can allow up to 7.5 million concurrent players seamlessly chat at the same time.[^1]The Nintendo Switch, a recent game console, uses Erlang to handle millions of concurrent connections.

Perhaps one of the best demonstrations of Erlang's scalability is WhatsApp. With over 900 million users worldwide, WhatsApp is one of the biggest chat apps on the market. In a record-setting day, 54 billion messages were sent in 24 hours. At the time, the engineering team had only thirty-two people. This small team was able to develop, scale, and support an incredibly large and reliable system with a small hardware footprint.[^1] Other chat apps, such as the Chinese WeChat, also use Erlang to support efficient messaging systems. 

Companies like Goldman Sachs, an investment banking giant, uses Erlang in its hedge fund trading platform. It requires a low latency data processing, strategy, and submission engine. It uses Erlang to deliver real time market fluctuations. Various cryptocurrencies and banking APIs use Erlang to ensure reliable and immediate transactions.[^1]

Even the English National Health Service (NHS) uses Erlang. With an obvious requirement for reliability and over 65 million record requests every day, NHS is the perfect example of Erlang's fault-tolerance. Health is a field which demands sound and steadfast systems. A failure could mean much more than simply a missed phone call or a lost chat message.

All-in-all, Erlang has demonstrated its reliability, scalability, and, most importantly, its fault tolerance from its smooth operation under rigid requirements. Erlang is not theoretical guesswork; it is built for the real-world. And so, we can confidently agree with Armstrong's conclusion; Erlang can build reliable applications.

[^1]: https://www.ericsson.com/en/about-us/history/changing-the-world/big-bang/axe-n
[^2]: https://codesync.global/media/https-youtu-be-077-xjv6plq/, at ~2:35
[^3]: https://www.statista.com/statistics/1134472/global-mobile-base-station-vendor-market-share/