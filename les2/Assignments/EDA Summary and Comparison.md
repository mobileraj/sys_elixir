Event driven architectures (EDAs) are built to handle and react to large amounts of data in real time. Computations are based on a series of events (called "behavioral data"). An event records a change or occurrence in the system. Each event has a timestamp, an action, and data. Whenever an event is produced, an event notification is sent to event consumers, who can handle the event asynchronously. The event producer does not need to know about its consumers or their implementation, the producer only needs to worry about publishing events (the producer and consumer are decoupled). As opposed to storing/processing a stream of events, relational models store the "now", the current state of the DB, within highly-structured tables. Relational models store/process data; EDAs store/process events.

EDAs replace the query/response model with a publisher/consumer model. In a typical query/response model, a client sends a request to the server, which processes the request and then sends a response back to the client. In a publisher/consumer model, one or more entities publish events which are then read and processed by one or more consumers. There are two main variants of this model: publish/subscribe and event stream models. In a publish/subscribe (pub/sub) model, many subscribers listen to a shared event channel on which the publishers posts events. Once an event is consumed, it is deleted. This implementation is highly decoupled; the publisher does not even know about its subscribers. Often the pub/sub model is best for applications where publishers must broadcast information to many consumers, such as in notification services. The event stream model is similar to pub/sub in that it decouples the publishers and consumers. In contrast to pub/sub, this model removes subscriptions; publishers produce a stream of events to a persistent log, which consumers can jump into at any time. Events are retained even after they are consumed, thus are ideal for things like fraud detection systems, which require a history of events. 

There are three main processing models[^ibm]: simple EP, event stream processing, and complex EP. In simple event processing, consumers process events exactly like the publishers send them, immediately trigging action. Event stream processing is similar to simple EP. However, in this model, events are passed through a pipeline of processors, which transform the stream of events, eventually passing them on to consumers. In complex event processing, consumers apply complex rules and aggregate events to recognize big-picture trends/patterns. These processing models can be used with pub/sub or event stream models.

The separation of services leads to many advantages in EDAs as opposed to relational architectures. A relational approach involves a centralized approach to data handling and processing. Since this approach does not differentiate between different services, it is difficult to adjust to an increased or decreased workload for only one particular component of the application. In an event driven system, a service can be scaled up simply by adding or removing instances of that service, without needing to re-engineer the code or scale up all the other services. In addition, components communicate asynchronously and do not need to worry about other components receiving their messages. This asynchronous handling of events typically improves performance as well as user experience, as they do not have to wait for other components to respond to their events. The responsiveness gained also allows for real-time processing. This is in contrast to the relational model, which follows a query/response (more-or-less client/server) model, where each query must wait for a response before being completed. Also, due to the decoupling that necessarily arises in EDAs, services (and their code) are relatively independent, increasing overall fault-tolerance and flexibility. Services can be added, removed, modified, and redeployed independently of each other. 

[^ibm]: In addition to the papers included, ibm's article [here](https://www.ibm.com/think/topics/event-driven-architecture) was used.

--------------- 
I'll just finish this with a personally interesting observation